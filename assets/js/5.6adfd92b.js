(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{283:function(t,e,a){t.exports=a.p+"assets/img/91_1.6bbb5e68.png"},284:function(t,e,a){t.exports=a.p+"assets/img/91_2.f24049fc.png"},285:function(t,e,a){t.exports=a.p+"assets/img/91_3.81171503.png"},286:function(t,e,a){t.exports=a.p+"assets/img/91_4.907368f1.png"},287:function(t,e,a){t.exports=a.p+"assets/img/91_5.e1321372.png"},288:function(t,e,a){t.exports=a.p+"assets/img/91_6.17ebf290.png"},359:function(t,e,a){"use strict";a.r(e);var n=[function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"_0x1-漏洞分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_0x1-漏洞分析","aria-hidden":"true"}},[t._v("#")]),t._v(" 0x1 漏洞分析")]),t._v(" "),n("p",[t._v("ff_rtmp_packet_read_internal 函数中循环读取服务器RTMP协议发送的chunk.")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("int ff_rtmp_packet_read_internal(URLContext *h, RTMPPacket *p, int chunk_size,\n                                 RTMPPacket **prev_pkt, int *nb_prev_pkt,\n                                 uint8_t hdr)\n{\n    while (1) {\n        int ret = rtmp_packet_read_one_chunk(h, p, chunk_size, prev_pkt,\n                                             nb_prev_pkt, hdr);\n        if (ret > 0 || ret != AVERROR(EAGAIN))\n            return ret;\n\n        if (ffurl_read(h, &hdr, 1) != 1)\n            return AVERROR(EIO);\n    }\n}\n")])])]),n("p",[t._v("rtmp_packet_read_one_chunk中根据channel_id判断是否读取过这个chunk。\n新的channel_id创建新的data buffer 存储数据，旧的channel_id直接用之前的data buffer。\nchunk_size可以控制，size的值为0x80\n这样首先发送一个channel_id=４ chunk_size=0xa0的chunk，接着发送一个同channel_id，chunk_size＝0x2000的chunk，在ffurl_read_complete读取数据的时发生溢出。\nff_rtmp_check_alloc_array　为RTMPPacket数组分配内存")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,\n                                      int chunk_size, RTMPPacket **prev_pkt_ptr,\n                                      int *nb_prev_pkt, uint8_t hdr)\n{\n\nchannel_id = hdr & 0x3F;\n...\n...\n\nif ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         channel_id)) < 0)\n        return ret;\n       \n...\n...\n\nif (!prev_pkt[channel_id].read) {\n        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                         size)) < 0)\n            return ret;\n        p->read = written;\n        p->offset = 0;\n        prev_pkt[channel_id].ts_field   = ts_field;\n        prev_pkt[channel_id].timestamp  = timestamp;\n} else {\n        // previous packet in this channel hasn't completed reading\n        RTMPPacket *prev = &prev_pkt[channel_id];\n        p->data          = prev->data;\n        p->size          = prev->size;\n        p->channel_id    = prev->channel_id;\n        p->type          = prev->type;\n        p->ts_field      = prev->ts_field;\n        p->extra         = prev->extra;\n        p->offset        = prev->offset;\n        p->read          = prev->read + written;\n        p->timestamp     = prev->timestamp;\n        prev->data       = NULL;\n    }\n    \n...\n\ntoread = FFMIN(size, chunk_size);\nif (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {\n        ff_rtmp_packet_destroy(p);\n        return AVERROR(EIO);\n    }\n\n\n...\n\n")])])]),n("table",[n("thead",[n("tr",[n("th",[t._v("av_realloc")]),t._v(" "),n("th",[t._v("ff_rtmp_packet_create")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("pkt->data = av_malloc(size);")]),t._v(" "),n("td",[t._v("av_realloc(NULL, size);")])])])]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("tcp_read <-")]),t._v(" "),n("th",[t._v("retry_transfer_wrapper <-")]),t._v(" "),n("th",[t._v("ffurl_read_complete")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("recv(s->fd, buf, size, 0);")]),t._v(" "),n("td",[t._v("transfer_func(h, buf + len, size - len);")]),t._v(" "),n("td",[t._v("retry_transfer_wrapper(h, buf, size, 1, h->prot->url_read);")])])])]),t._v(" "),n("h1",{attrs:{id:"_0x2-漏洞利用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_0x2-漏洞利用","aria-hidden":"true"}},[t._v("#")]),t._v(" 0x2 漏洞利用")]),t._v(" "),n("p",[t._v("RTMPPacket 结构体")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("typedef struct RTMPPacket {\n    int            channel_id; ///< RTMP channel ID (nothing to do with audio/video channels though)\n    RTMPPacketType type;       ///< packet payload type\n    uint32_t       timestamp;  ///< packet full timestamp\n    uint32_t       ts_field;   ///< 24-bit timestamp or increment to the previous one, in milliseconds (latter only for media packets). Clipped to a maximum of 0xFFFFFF, indicating an extended timestamp field.\n    uint32_t       extra;      ///< probably an additional channel ID used during streaming data\n    uint8_t        *data;      ///< packet payload\n    int            size;       ///< packet payload size\n    int            offset;     ///< amount of data read so far\n    int            read;       ///< amount read, including headers\n} RTMPPacket;\n")])])]),n("p",[t._v("ff_rtmp_check_alloc_array函数为RTMPPacket数组realloc内存，此时prev_pkt 在pkt->data地址后边，可以覆盖RTMPPacket中的data指针，向RTMPPacket->data 中写数据时，已经控制了RTMPPacket中的 data 指针，可以做到任意地址写。\n利用任意地址写覆盖got 表中的realloc，这样在一次调用realloc时执行rop。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("int ff_rtmp_check_alloc_array(RTMPPacket **prev_pkt, int *nb_prev_pkt,\n                              int channel)\n{\n    int nb_alloc;\n    RTMPPacket *ptr;\n    if (channel < *nb_prev_pkt)\n        return 0;\n\n    nb_alloc = channel + 16; \n    // This can't use the av_reallocp family of functions, since we\n    // would need to free each element in the array before the array\n    // itself is freed.\n    ptr = av_realloc_array(*prev_pkt, nb_alloc, sizeof(**prev_pkt));\n    ...\n    ...\n    return 0;\n}\n")])])]),n("p",[t._v("利用可控寄存器把栈迁移到堆上\n"),n("img",{attrs:{src:a(283),alt:"avatar"}}),t._v(" "),n("img",{attrs:{src:a(284),alt:"avatar"}})]),t._v(" "),n("p",[t._v("利用add rep 指令调整栈到mprotect　rop上，设置0x00400000内存的权限\n"),n("img",{attrs:{src:a(285),alt:"avatar"}}),t._v(" "),n("img",{attrs:{src:a(286),alt:"avatar"}})]),t._v(" "),n("p",[t._v("利用 mov    QWORD PTR [rdx],rax把shellcode复制到0x00400000\n"),n("img",{attrs:{src:a(287),alt:"avatar"}})]),t._v(" "),n("p",[t._v("shellcode\n"),n("img",{attrs:{src:a(288),alt:"avatar"}})])])}],r=a(1),_=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},n,!1,null,null,null);e.default=_.exports}}]);