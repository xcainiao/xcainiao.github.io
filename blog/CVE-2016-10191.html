<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>CVE-2016-10191 FFmpeg Heap Overflow | Hello</title>
    <meta name="description" content="1">
    
    
    <link rel="preload" href="/assets/css/0.styles.153793e6.css" as="style"><link rel="preload" href="/assets/js/app.fb63a1b9.js" as="script"><link rel="preload" href="/assets/js/5.6adfd92b.js" as="script"><link rel="prefetch" href="/assets/js/10.6aae25a8.js"><link rel="prefetch" href="/assets/js/11.e5a6ecb1.js"><link rel="prefetch" href="/assets/js/12.e6734d6c.js"><link rel="prefetch" href="/assets/js/13.c45be31f.js"><link rel="prefetch" href="/assets/js/14.7fe2edb8.js"><link rel="prefetch" href="/assets/js/15.7d96271b.js"><link rel="prefetch" href="/assets/js/16.d5c5556b.js"><link rel="prefetch" href="/assets/js/17.1a634ded.js"><link rel="prefetch" href="/assets/js/18.e6787f4e.js"><link rel="prefetch" href="/assets/js/19.a31276f8.js"><link rel="prefetch" href="/assets/js/2.6cf84733.js"><link rel="prefetch" href="/assets/js/20.f1ebd130.js"><link rel="prefetch" href="/assets/js/21.9fd25a7d.js"><link rel="prefetch" href="/assets/js/22.7ec64c15.js"><link rel="prefetch" href="/assets/js/23.a0a7d0ea.js"><link rel="prefetch" href="/assets/js/24.c17f3010.js"><link rel="prefetch" href="/assets/js/25.9bbf45e5.js"><link rel="prefetch" href="/assets/js/26.4f930016.js"><link rel="prefetch" href="/assets/js/27.b6d66343.js"><link rel="prefetch" href="/assets/js/28.ded43c8f.js"><link rel="prefetch" href="/assets/js/29.35b25580.js"><link rel="prefetch" href="/assets/js/3.88ebc755.js"><link rel="prefetch" href="/assets/js/30.a0b7fe3b.js"><link rel="prefetch" href="/assets/js/31.89d75be7.js"><link rel="prefetch" href="/assets/js/32.d7c054e6.js"><link rel="prefetch" href="/assets/js/33.9a5f3e99.js"><link rel="prefetch" href="/assets/js/34.ee5cfb6f.js"><link rel="prefetch" href="/assets/js/35.2054ab64.js"><link rel="prefetch" href="/assets/js/36.73bb48c1.js"><link rel="prefetch" href="/assets/js/37.5a1d6d20.js"><link rel="prefetch" href="/assets/js/38.c7d42097.js"><link rel="prefetch" href="/assets/js/39.fd864930.js"><link rel="prefetch" href="/assets/js/4.dc8e7db2.js"><link rel="prefetch" href="/assets/js/40.6c289e11.js"><link rel="prefetch" href="/assets/js/41.0ed23031.js"><link rel="prefetch" href="/assets/js/42.10b887da.js"><link rel="prefetch" href="/assets/js/43.d348e521.js"><link rel="prefetch" href="/assets/js/44.f98660b8.js"><link rel="prefetch" href="/assets/js/45.a141b3d0.js"><link rel="prefetch" href="/assets/js/46.3a3b1b86.js"><link rel="prefetch" href="/assets/js/47.d2f1996d.js"><link rel="prefetch" href="/assets/js/48.0bd12b2f.js"><link rel="prefetch" href="/assets/js/6.f9bcea16.js"><link rel="prefetch" href="/assets/js/7.ad2cffde.js"><link rel="prefetch" href="/assets/js/8.8932bce4.js"><link rel="prefetch" href="/assets/js/9.892cc635.js">
    <link rel="stylesheet" href="/assets/css/0.styles.153793e6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="page-main"><div class="component-nav-menu"><div class="placeholder"></div> <div class="search-wrapper"><div aria-haspopup="listbox" role="combobox" aria-owns="el-autocomplete-9797" class="el-autocomplete"><div class="el-input el-input--prefix"><!----><input type="text" autocomplete="off" valueKey="title" placeholder="请输入内容" fetchSuggestions="function () { [native code] }" triggerOnFocus="true" debounce="300" placement="bottom-start" popperAppendToBody="true" background-color="#eee" class="el-input__inner"><span class="el-input__prefix"><i class="el-input__icon el-icon-search"></i></span><!----><!----><!----></div><div role="region" class="el-autocomplete-suggestion el-popper" style="width:;display:none;"><div class="el-scrollbar"><div class="el-autocomplete-suggestion__wrap el-scrollbar__wrap el-scrollbar__wrap--hidden-default"><ul class="el-scrollbar__view el-autocomplete-suggestion__list"></ul></div><div class="el-scrollbar__bar is-horizontal"><div class="el-scrollbar__thumb" style="width:0;transform:translateX(0%);ms-transform:translateX(0%);webkit-transform:translateX(0%);"></div></div><div class="el-scrollbar__bar is-vertical"><div class="el-scrollbar__thumb" style="height:0;transform:translateY(0%);ms-transform:translateY(0%);webkit-transform:translateY(0%);"></div></div></div></div></div></div> <ul role="menubar" class="el-menu--horizontal el-menu" style="background-color:;"><li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;">
        Home
      </li><li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;">
        Blog
      </li><li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;">
        TimeLine
      </li><li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;">
        Github
      </li><li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;">
        About
      </li></ul></div> <div class="page-container"><div class="component-page"><div class="page-content"><!----> <div class="content custom"><h1 id="_0x1-漏洞分析"><a href="#_0x1-漏洞分析" aria-hidden="true" class="header-anchor">#</a> 0x1 漏洞分析</h1> <p>ff_rtmp_packet_read_internal 函数中循环读取服务器RTMP协议发送的chunk.</p> <div class="language- extra-class"><pre class="language-text"><code>int ff_rtmp_packet_read_internal(URLContext *h, RTMPPacket *p, int chunk_size,
                                 RTMPPacket **prev_pkt, int *nb_prev_pkt,
                                 uint8_t hdr)
{
    while (1) {
        int ret = rtmp_packet_read_one_chunk(h, p, chunk_size, prev_pkt,
                                             nb_prev_pkt, hdr);
        if (ret &gt; 0 || ret != AVERROR(EAGAIN))
            return ret;

        if (ffurl_read(h, &amp;hdr, 1) != 1)
            return AVERROR(EIO);
    }
}
</code></pre></div><p>rtmp_packet_read_one_chunk中根据channel_id判断是否读取过这个chunk。
新的channel_id创建新的data buffer 存储数据，旧的channel_id直接用之前的data buffer。
chunk_size可以控制，size的值为0x80
这样首先发送一个channel_id=４ chunk_size=0xa0的chunk，接着发送一个同channel_id，chunk_size＝0x2000的chunk，在ffurl_read_complete读取数据的时发生溢出。
ff_rtmp_check_alloc_array　为RTMPPacket数组分配内存</p> <div class="language- extra-class"><pre class="language-text"><code>static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,
                                      int chunk_size, RTMPPacket **prev_pkt_ptr,
                                      int *nb_prev_pkt, uint8_t hdr)
{

channel_id = hdr &amp; 0x3F;
...
...

if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,
                                         channel_id)) &lt; 0)
        return ret;
       
...
...

if (!prev_pkt[channel_id].read) {
        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,
                                         size)) &lt; 0)
            return ret;
        p-&gt;read = written;
        p-&gt;offset = 0;
        prev_pkt[channel_id].ts_field   = ts_field;
        prev_pkt[channel_id].timestamp  = timestamp;
} else {
        // previous packet in this channel hasn't completed reading
        RTMPPacket *prev = &amp;prev_pkt[channel_id];
        p-&gt;data          = prev-&gt;data;
        p-&gt;size          = prev-&gt;size;
        p-&gt;channel_id    = prev-&gt;channel_id;
        p-&gt;type          = prev-&gt;type;
        p-&gt;ts_field      = prev-&gt;ts_field;
        p-&gt;extra         = prev-&gt;extra;
        p-&gt;offset        = prev-&gt;offset;
        p-&gt;read          = prev-&gt;read + written;
        p-&gt;timestamp     = prev-&gt;timestamp;
        prev-&gt;data       = NULL;
    }
    
...

toread = FFMIN(size, chunk_size);
if (ffurl_read_complete(h, p-&gt;data + p-&gt;offset, toread) != toread) {
        ff_rtmp_packet_destroy(p);
        return AVERROR(EIO);
    }


...

</code></pre></div><table><thead><tr><th>av_realloc</th> <th>ff_rtmp_packet_create</th></tr></thead> <tbody><tr><td>pkt-&gt;data = av_malloc(size);</td> <td>av_realloc(NULL, size);</td></tr></tbody></table> <table><thead><tr><th>tcp_read &lt;-</th> <th>retry_transfer_wrapper &lt;-</th> <th>ffurl_read_complete</th></tr></thead> <tbody><tr><td>recv(s-&gt;fd, buf, size, 0);</td> <td>transfer_func(h, buf + len, size - len);</td> <td>retry_transfer_wrapper(h, buf, size, 1, h-&gt;prot-&gt;url_read);</td></tr></tbody></table> <h1 id="_0x2-漏洞利用"><a href="#_0x2-漏洞利用" aria-hidden="true" class="header-anchor">#</a> 0x2 漏洞利用</h1> <p>RTMPPacket 结构体</p> <div class="language- extra-class"><pre class="language-text"><code>typedef struct RTMPPacket {
    int            channel_id; ///&lt; RTMP channel ID (nothing to do with audio/video channels though)
    RTMPPacketType type;       ///&lt; packet payload type
    uint32_t       timestamp;  ///&lt; packet full timestamp
    uint32_t       ts_field;   ///&lt; 24-bit timestamp or increment to the previous one, in milliseconds (latter only for media packets). Clipped to a maximum of 0xFFFFFF, indicating an extended timestamp field.
    uint32_t       extra;      ///&lt; probably an additional channel ID used during streaming data
    uint8_t        *data;      ///&lt; packet payload
    int            size;       ///&lt; packet payload size
    int            offset;     ///&lt; amount of data read so far
    int            read;       ///&lt; amount read, including headers
} RTMPPacket;
</code></pre></div><p>ff_rtmp_check_alloc_array函数为RTMPPacket数组realloc内存，此时prev_pkt 在pkt-&gt;data地址后边，可以覆盖RTMPPacket中的data指针，向RTMPPacket-&gt;data 中写数据时，已经控制了RTMPPacket中的 data 指针，可以做到任意地址写。
利用任意地址写覆盖got 表中的realloc，这样在一次调用realloc时执行rop。</p> <div class="language- extra-class"><pre class="language-text"><code>int ff_rtmp_check_alloc_array(RTMPPacket **prev_pkt, int *nb_prev_pkt,
                              int channel)
{
    int nb_alloc;
    RTMPPacket *ptr;
    if (channel &lt; *nb_prev_pkt)
        return 0;

    nb_alloc = channel + 16; 
    // This can't use the av_reallocp family of functions, since we
    // would need to free each element in the array before the array
    // itself is freed.
    ptr = av_realloc_array(*prev_pkt, nb_alloc, sizeof(**prev_pkt));
    ...
    ...
    return 0;
}
</code></pre></div><p>利用可控寄存器把栈迁移到堆上
<img src="/assets/img/91_1.6bbb5e68.png" alt="avatar"> <img src="/assets/img/91_2.f24049fc.png" alt="avatar"></p> <p>利用add rep 指令调整栈到mprotect　rop上，设置0x00400000内存的权限
<img src="/assets/img/91_3.81171503.png" alt="avatar"> <img src="/assets/img/91_4.907368f1.png" alt="avatar"></p> <p>利用 mov    QWORD PTR [rdx],rax把shellcode复制到0x00400000
<img src="/assets/img/91_5.e1321372.png" alt="avatar"></p> <p>shellcode
<img src="/assets/img/91_6.17ebf290.png" alt="avatar"></p></div></div></div></div></div></div>
    <script src="/assets/js/app.fb63a1b9.js" defer></script><script src="/assets/js/5.6adfd92b.js" defer></script>
  </body>
</html>
